工厂模式（Factory Pattern）：工厂模式是一种创建型模式，它提供了一种创建对象的最佳方式，而无需将具体类暴露给客户端。C++中可以通过工厂方法或抽象工厂来实现。

单例模式（Singleton Pattern）：单例模式确保类只有一个实例，并提供一个全局访问点。这在需要全局访问点，如日志类或配置类时很有用。

适配器模式（Adapter Pattern）：适配器模式允许接口不兼容的类之间进行合作。它通常用于旧代码与新代码之间的过渡，或者在不修改现有代码的情况下为类添加新功能。

观察者模式（Observer Pattern）：观察者模式定义了一种一对多的依赖关系，使得当一个对象的状态发生变化时，所有依赖于它的对象都会得到通知并自动更新。

策略模式（Strategy Pattern）：策略模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换。这种模式使得算法可以独立于使用它的客户端而变化。

装饰器模式（Decorator Pattern）：装饰器模式允许向现有对象动态添加功能，同时又不改变其接口。这种模式是继承的一种替代方案，可以避免类爆炸问题。

模板方法模式（Template Method Pattern）：模板方法模式定义了一个操作中的算法框架，将一些步骤延迟到子类中实现。这样可以在不改变算法结构的情况下重新定义算法的某些步骤。

代理模式（Proxy Pattern）：代理模式为其他对象提供一种代理以控制对这个对象的访问。这种模式通常用于实现延迟加载、访问控制或日志记录等功能。

状态模式（State Pattern）：状态模式允许对象在其内部状态改变时改变其行为。这种模式将对象的行为包装在不同的状态类中，并允许对象动态地改变状态。

享元模式（Flyweight Pattern）：享元模式用于减少系统中对象的数量，以节省内存和提高性能。它通过共享相似对象之间的公共部分来实现。

命令模式（Command Pattern）：命令模式将请求封装成一个对象，从而允许客户端参数化处理请求。这种模式允许请求的发送者和接收者解耦。

组合模式（Composite Pattern）：组合模式允许客户端将对象组合成树形结构以表示“部分-整体”的层次结构。这种模式使得客户端可以统一对待单个对象和组合对象。

迭代器模式（Iterator Pattern）：迭代器模式提供了一种访问对象集合元素的方法，而无需暴露其底层表示。这种模式使得可以按顺序访问集合中的元素，而不用关心其内部实现。

访问者模式（Visitor Pattern）：访问者模式允许在不修改对象结构的情况下向对象结构中添加新的操作。这种模式通过将操作封装在访问者类中来实现。

备忘录模式（Memento Pattern）：备忘录模式允许在不破坏封装的前提下捕获和恢复对象的内部状态。这种模式通常与命令模式结合使用，以实现撤销和重做功能。

解释器模式（Interpreter Pattern）：解释器模式定义了一种语言的文法，并提供了解释器来解释这种语言中的句子。这种模式通常用于解释配置文件或规则引擎等。

桥接模式（Bridge Pattern）：桥接模式将抽象部分与实现部分分离，使它们可以独立变化。这种模式通常用于处理多维变化的情况，如不同平台或不同数据库的切换。

中介者模式（Mediator Pattern）：中介者模式定义了一个中介对象来封装一组对象之间的交互。这种模式可以减少对象之间的直接依赖关系，从而降低耦合度。

责任链模式（Chain of Responsibility Pattern）：责任链模式允许多个对象处理请求，而不需要知道请求的发送者和接收者。这种模式可以动态地构建处理链，并在运行时决定请求的处理者。

命令模板模式（Command Template Pattern）：命令模板模式结合了命令模式和模板方法模式的特点，提供了一种在命令模式中执行一系列命令的方法。

观察者模板模式（Observer Template Pattern）：观察者模板模式结合了观察者模式和模板方法模式的特点，提供了一种定义一组观察者方法的方法。

代理模板模式（Proxy Template Pattern）：代理模板模式结合了代理模式和模板方法模式的特点，提供了一种在代理模式中执行一系列操作的方法。

状态模板模式（State Template Pattern）：状态模板模式结合了状态模式和模板方法模式的特点，提供了一种在状态模式中执行一系列操作的方法。